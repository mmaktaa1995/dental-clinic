// Not only send the vue component, but also the file path
// keys should be english and namespaced, dot separated
// should start with the module name?
// Research: does outputting a "diff" work?
// Research: does it make a difference to the llm if we remove whitespace?
// Maybe only send the <template> part? Or send template and script in 2 requests
// Find everything that can be put into a translation system
// Research which one is better:
// -    ...
// +    {{ $t('foo.bar') }} <br />
//
//     'foo.bar': 'Um alle neuen Funktionen zu unterstützen, muss dieses Zertifikat aktualisiert werden.'
// or:
// whole component and then
// {{ temporaryTranslationCall('foo.bar', 'Um alle neuen ...') }}
// (and then we parse it with regex)

/* eslint-disable no-shadow */

// Replace 'your_api_key' with your actual API key for OpenAI or use process.env.OPENAI_API_KEY

const fs = require("fs").promises

const OPENAI_API_KEY = process.env.API_KEY

function showLoading(message) {
    const frames = ["-", "\\", "|", "/"]
    let index = 0

    const interval = setInterval(() => {
        if (index === 0) {
            message = `\r${message} -`
        } else {
            message = `-`
        }
        process.stdout.write(`${message}`)
        index = (index + 1) % frames.length
    }, 1000)

    return () => {
        clearInterval(interval)
        process.stdout.write("\r\n") // Clear the line
    }
}

const sendToOpenAI = async (fileContent, filePath) => {
    const content = `${filePath}\n${fileContent}`
    const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${OPENAI_API_KEY}`,
        },
        body: JSON.stringify({
            model: "gpt-4o-mini-2024-07-18",
            messages: [
                {
                    role: "system",
                    content: `You are a tool that transforms Vue 3 SFC code, preparing it for use with the translation system.
You should replace regular text with translation functions using the function $t('module.key').
The module name is provided before the code.
The key should contain important information from the regular text, in English.
The key should be in camelCase.
Replace all hardcoded strings in the template.
Replace hardcoded strings in parameters and properties.
Leave alone all strings already using our translation function $t().
Output ONLY the code of the changed file.
For ex:
module: courses
<template>
  <div>
    Are you sure you want to save the changes?
    <v-alert message="This is an important message" color="primary" />
    <KButton flat color="red">Save Changes</KButton>
  </div>
</template>
Should be:
<template>
  <div>
    {{ $t('courses.saveDialog', 'Are you sure you want to save the changes?') }}
    <v-alert :message="$t('courses.importantMessage')" color="primary" />
    <KButton flat color="red">{{ $t('courses.saveChanges') }}</KButton>
  </div>
</template>

<script setup>Fix and convert the code here  also to be compatible with vue 3 and setup attribute in the script tag. Don't miss any import for the newely generated code. Any code related to moment please conver tit to use date-fns</script>
<style lang="scss">Copy the style here if exists and convert it to Scss</style>

 and don't remove any of the html content or script tag or style tag also, append them to the generated component with fixes that already mentioned before


Here are the custom components names

CAsyncButton
CBarChart
CPieChart
CApexPolarChart
CApexBarChart
CApexLineChart
CFilePondComponent
CSearch
CSearchDetails
CSearchEmptyResults
CLoader
CMetric
CPagination
CIconArrowDown
CIconArrowUp
CIconRefresh
CIconSearch
CIconCloud
CIconCollection
CIconBars
CIconUsers
CIconExclamation
CIconDesktopComputer
CIconDotsVertical
CIconLoader
CIconFlag
CIconCalendar
CIconFile
CIconList
CIconClipboardCopy
CIconChevronRight
CIconEye
CIconEdit
CIconDelete
CIconChartBar
CIconTerminal
CIconXCircle
CIconInformationCircle
CIconExpenses
CIconMoney
CIconDebit
CIconRestore
CFlashMessage
CDocumentIcon

and after that also return the founded texts array with their keys and also translate them to English

So the response will be like this {component: will contain the html code generated by you like above, translations: array of translation should have the key with its founded text in the component and the translation for these texts [{key: "courses.saveChanges", "text": "حفظ", "text_en":"Save Changes"}]}

The response should be json

`,
                },
                {
                    role: "user",
                    content: content,
                },
            ],
            temperature: 1,
            max_tokens: 8096,
            top_p: 1,
            frequency_penalty: 0,
            presence_penalty: 0,
        }),
    })

    if (!response.ok) {
        console.log(await response.json())
        throw new Error(`OpenAI API request failed: ${response.statusText}`)
    }

    const responseData = await response.json()
    return responseData.choices[0].message.content
}

function replacePlaceholders(str, data) {
    function doReplacement(str, addQuotes) {
        return str.replace(/(["']*%%%([^%]+)%%%["']*)/g, (match, outer, path) => {
            const keys = path.split(".")
            let value = data
            for (const key of keys) {
                value = value[key]
                if (value === undefined) {
                    return match // If key doesn't exist, keep the placeholder
                }
            }
            if (addQuotes) {
                return `"${value}"`
            }
            return value
        })
    }

    str = str.replace(/<template>([\s\S]+)<\/template>/, (template) => {
        return doReplacement(template, false)
    })

    str = str.replace(/<script>([\s\S]+)<\/script>/, (script) => {
        return doReplacement(script, true)
    })

    return str
}

function setNestedTranslations(obj, keyPath, value) {
    const keys = keyPath.split(".")
    let current = obj

    keys.forEach((key, index) => {
        if (!current[key]) {
            current[key] = {}
        }
        if (index === keys.length - 1) {
            current[key] = value // Set the value at the final key
        } else {
            current = current[key]
        }
    })
}

async function replaceLangMessages(content) {
    const arTranslations = JSON.parse(await fs.readFile("./resources/js/lang/ar.json"), "utf8")
    const translations = JSON.parse(await fs.readFile("./resources/js/lang/en.json"), "utf8")

    content.translations.forEach((item) => {
        setNestedTranslations(arTranslations, item.key, item.text)
        setNestedTranslations(translations, item.key, item.text_en)
    })
    await fs.writeFile("./resources/js/lang/ar.json", JSON.stringify(arTranslations))
    await fs.writeFile("./resources/js/lang/en.json", JSON.stringify(translations))
}
const excludedFilePaths = [
    /*"./resources/js/screens/403.vue", "./resources/js/screens/404.vue"*/
]

const main = async (files, index = 0) => {
    const filePath = files[index]
    console.log(`Start processing ${filePath}! \n\n`)
    const stopLoading = showLoading("Processing \n")
    try {
        if (!OPENAI_API_KEY) {
            throw new Error("OpenAI API key is missing. Please set your OPENAI_API_KEY environment variable.")
        }
        // Read the file's content as utf-8
        const fileContent = await fs.readFile(filePath, "utf8")

        let response = await sendToOpenAI(fileContent, filePath)
        response = JSON.parse(response.replace("```json", "").replace("```", ""))
        const newFileContent = await replaceLangMessages(response)

        // Update the file with the response from OpenAI
        await fs.writeFile(filePath, response.component)
        excludedFilePaths.push(filePath)
        console.log(`File updated successfully with the response from OpenAI: ${filePath} \n`)
    } catch (error) {
        console.log(error.stack)
        console.error("Error:", error.message)
    } finally {
        stopLoading()
    }
    setTimeout(() => {
        main(files, ++index)
    })
}

// Get the file path from command line arguments
// const filePath = process.argv[2]
//
// // Call the main function with the file path
// if (!filePath) {
//     console.log("Please provide a file path as a parameter.")
// } else {
// main("./resources/js/screens/appointments/create.vue")
// }

async function getFilesInFolder(folderPath) {
    const fileList = []

    async function traverseDirectory(currentPath) {
        const items = await fs.readdir(currentPath)
        for (const item of items) {
            if (item === ".DS_Store") {
                continue
            }
            const fullPath = currentPath + "/" + item
            const stats = await fs.stat(fullPath)

            if (stats.isDirectory()) {
                // Recursively traverse subfolders
                traverseDirectory(fullPath)
            } else {
                // Add file to the list
                fileList.push(fullPath)
            }
        }
    }

    await traverseDirectory(folderPath)
    return fileList
}

const folderPath = "./resources/js/screens"
getFilesInFolder(folderPath).then((files) => {
    main(files)
})
