<template>
    <div class="min-h-screen bg-gray-50">
      <!-- Password Protection -->
      <div v-if="!passwordCorrect" class="flex items-center justify-center min-h-screen bg-gray-50">
        <div class="w-full max-w-md p-8 space-y-8 bg-white rounded-lg shadow">
          <div class="text-center">
            <h2 class="text-3xl font-extrabold text-gray-900">{{ $t('statistics.title') }}</h2>
            <p class="mt-2 text-sm text-gray-600">
              {{ $t('statistics.enter_password_to_continue') }}
            </p>
          </div>
          <div class="mt-8 space-y-6">
            <div class="space-y-1">
              <label for="password" class="block text-sm font-medium text-gray-700">
                {{ $t('auth.password') }}
              </label>
              <input
                id="password"
                v-model="password"
                name="password"
                type="password"
                autocomplete="current-password"
                required
                class="block w-full px-3 py-2 placeholder-gray-400 border border-gray-300 rounded-md shadow-sm appearance-none focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                @keyup.enter="handleLogin"
              />
            </div>
            <div>
              <button
                type="button"
                @click="handleLogin"
                class="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                :disabled="loading"
              >
                <span v-if="!loading">{{ $t('global.actions.sign_in') }}</span>
                <span v-else>{{ $t('global.actions.loading') }}</span>
              </button>
            </div>
          </div>
        </div>
      </div>
  
      <!-- Main Content -->
      <div v-else class="p-4 md:p-6">
        <!-- Header -->
        <div class="flex flex-col justify-between mb-6 space-y-4">
          <div>
            <h1 class="text-2xl font-bold text-gray-900">{{ $t('statistics.title') }}</h1>
            <p class="mt-1 text-sm text-gray-500">{{ greeting }}, {{ formattedDate }}</p>
          </div>
  
          <!-- Date Filters -->
          <div class="grid grid-cols-4 gap-4">
            <CSelect
              id="year"
              :label="$t('common.year')"
              :options="years"
              v-model="selectedYear"
              @change="handleYearChange"
            />
            <CSelect
              id="month"
              :label="$t('common.month')"
              :options="months"
              v-model="selectedMonth"
              @change="handleMonthChange"
            />
            <CSelect
              id="day"
              :label="$t('common.day')"
              :options="days"
              v-model="selectedDay"
              @change="fetchData"
            />
  
            <div class="flex items-end">
              <CButton type="info" @click="fetchData" :disabled="loading">
                <span v-if="!loading">{{ $t('global.actions.refresh') }}</span>
                <span v-else>{{ $t('global.actions.loading') }}</span>
                <svg
                  class="w-5 h-5 ml-2 text-white"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                  :class="{ 'animate-spin': loading }"
                >
                  <path
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    stroke-width="2"
                    d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                  />
                </svg>
              </CButton>
            </div>
          </div>
        </div>
  
        <!-- Stats Widgets -->
        <div class="grid grid-cols-1 gap-6 mt-6 sm:grid-cols-2 lg:grid-cols-4">
          <div v-for="(widget, index) in widgets" :key="index" class="p-6 bg-white rounded-lg shadow">
            <div class="flex items-center">
              <div
                class="w-10 h-10 rounded-full flex items-center justify-center"
                :class="widget.iconBgColor"
              >
                <i :class="widget.icon" class="text-white"></i>
              </div>
              <div class="mr-4 ltr:m-l4 ltr:m-r0">
                <p class="text-sm font-medium text-gray-500">
                  {{ $t(widget.label) }}
                </p>
                <p class="text-2xl font-semibold text-gray-900">
                  {{ widget.value }}
                </p>
              </div>
            </div>
          </div>
        </div>
  
        <!-- Charts Section -->
        <div class="mt-8 grid grid-cols-1 lg:grid-cols-2 gap-6">
          <!-- Revenue vs Expenses Chart -->
          <div class="bg-white p-6 rounded-lg shadow">
            <div class="h-80">
              <canvas id="revenueChart"></canvas>
            </div>
          </div>
  
          <!-- Patient Growth Chart -->
          <div class="bg-white p-6 rounded-lg shadow">
            <div class="h-80">
              <canvas id="patientsChart"></canvas>
            </div>
          </div>
  
          <!-- Expenses by Category Chart -->
          <div class="bg-white p-6 rounded-lg shadow">
            <div class="h-96">
              <canvas id="expensesChart"></canvas>
            </div>
          </div>
  
          <!-- Appointments by Status Chart -->
          <div class="bg-white p-6 rounded-lg shadow">
            <div class="h-96">
              <canvas id="appointmentsChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </div>
  </template>
  
  <script setup lang="ts">
  import { ref, computed, onMounted, onBeforeUnmount } from 'vue';
  import { format, parseISO } from 'date-fns';
  import { useI18n } from 'vue-i18n';
  import { api } from '@/logic/api';
  import CSelect from '@/components/CSelect.vue';
  import CButton from '@/components/CButton.vue';
  import { Chart, ChartConfiguration, registerables } from 'chart.js';
  import 'chartjs-adapter-date-fns';
  
  // Register Chart.js components
  console.log(registerables);
//   Chart.register(...registerables);
  
  const { t } = useI18n();
  
  // Authentication state
  const passwordCorrect = ref<boolean>(false);
  const password = ref<string>('');
  const loading = ref<boolean>(false);
  const error = ref<string>('');
  
  // Date filter state
  const currentDate = new Date();
  const selectedYear = ref<number>(currentDate.getFullYear());
  const selectedMonth = ref<number | null>(currentDate.getMonth() + 1);
  const selectedDay = ref<number | null>(null);
  
  // Statistics data
  interface StatsData {
    totalAppointments: number;
    totalRevenue: number;
    totalExpenses: number;
    totalProfit: number;
    expenses: Array<{ date: string; amount: string; category?: string }>;
    visits: Array<{ date: string; status: string }>;
    patients: Array<{ date: string; count: number }>;
    incomes: Array<{ date: string; amount: string }>;
    debts: Array<{ amount: string }>;
    totalPatientsCount: number;
    totalIncome: number;
    totalDebts: number;
  }
  
  const stats = ref<StatsData>({
    totalAppointments: 0,
    totalRevenue: 0,
    totalExpenses: 0,
    totalProfit: 0,
    expenses: [],
    visits: [],
    patients: [],
    incomes: [],
    debts: [],
    totalPatientsCount: 0,
    totalIncome: 0,
    totalDebts: 0,
  });
  
  // Chart instances
  const charts = ref<{[key: string]: Chart | null}>({
    revenueChart: null,
    patientsChart: null,
    expensesChart: null,
    appointmentsChart: null
  });
  
  // Chart colors
  const chartColors = {
    blue: '#3b82f6',
    green: '#10b981',
    red: '#ef4444',
    yellow: '#f59e0b',
    purple: '#8b5cf6',
    pink: '#ec4899',
    indigo: '#6366f1',
    teal: '#14b8a6',
    orange: '#f97316',
    cyan: '#06b6d4',
  };
  
  // Chart options
  const chartOptions = {
    responsive: true,
    maintainAspectRatio: false,
    plugins: {
      legend: {
        position: 'top' as const,
      },
      tooltip: {
        mode: 'index' as const,
        intersect: false,
      },
    },
    scales: {
      x: {
        grid: {
          display: false,
        },
      },
      y: {
        beginAtZero: true,
        grid: {
          borderDash: [3, 3],
        },
      },
    },
  };
  
  // Computed properties
  const greeting = computed(() => {
    const hour = currentDate.getHours();
    if (hour < 12) return t('common.good_morning');
    if (hour < 18) return t('common.good_afternoon');
    return t('common.good_evening');
  });
  
  const formattedDate = computed(() => {
    return format(currentDate, 'EEEE, MMMM d, yyyy');
  });
  
  const years = computed(() => {
    const currentYear = new Date().getFullYear();
    return Array.from({ length: 5 }, (_, i) => ({
      id: currentYear - i,
      label: String(currentYear - i),
    }));
  });
  
  const months = computed(() => {
    return Array.from({ length: 12 }, (_, i) => ({
      id: i + 1,
      label: t(`months.${[
        'january',
        'february',
        'march',
        'april',
        'may',
        'june',
        'july',
        'august',
        'september',
        'october',
        'november',
        'december'
      ][i]}`),
    }));
  });
  
  const days = computed(() => {
    if (!selectedMonth.value || !selectedYear.value) return [];
    const daysInMonth = new Date(selectedYear.value, selectedMonth.value, 0).getDate();
    return Array.from({ length: daysInMonth }, (_, i) => ({
      id: i + 1,
      label: String(i + 1),
    }));
  });
  
  interface StatWidget {
    label: string;
    value: string | number;
    icon: string;
    iconBgColor: string;
  }
  
  const widgets = computed<StatWidget[]>(() => [
    {
      label: 'statistics.total_patients',
      value: stats.value.totalPatientsCount,
      icon: 'fas fa-users',
      iconBgColor: 'bg-blue-500',
    },
    {
      label: 'statistics.total_income',
      value: formatCurrency(stats.value.totalIncome),
      icon: 'fas fa-money-bill-wave',
      iconBgColor: 'bg-green-500',
    },
    {
      label: 'statistics.total_expenses',
      value: formatCurrency(stats.value.totalExpenses),
      icon: 'fas fa-receipt',
      iconBgColor: 'bg-yellow-500',
    },
    {
      label: 'statistics.total_debts',
      value: formatCurrency(stats.value.totalDebts),
      icon: 'fas fa-file-invoice-dollar',
      iconBgColor: 'bg-red-500',
    },
  ]);
  
  // Format currency helper
  const formatCurrency = (value: number): string => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(value);
  };
  
  const handleLogin = async (): Promise<void> => {
    if (!password.value) {
      error.value = t('validation.required', { field: t('auth.password') });
      return;
    }
  
    loading.value = true;
    error.value = '';
  
    try {
      // In a real app, verify password with backend
      const response = await api.post('/api/verify-stats-password', {
        password: password.value,
      });
  
      if (response.data?.valid) {
        passwordCorrect.value = true;
        localStorage.setItem('statsAuthenticated', 'true');
        await fetchData();
      } else {
        error.value = t('auth.invalid_credentials');
      }
    } catch (err: any) {
      error.value = err.response?.data?.message || t('errors.generic');
    } finally {
      loading.value = false;
    }
  };
  
  const handleYearChange = (year: number): void => {
    selectedYear.value = year;
    selectedDay.value = null;
    fetchData();
  };
  
  const handleMonthChange = (month: number): void => {
    selectedMonth.value = month;
    selectedDay.value = null;
    fetchData();
  };
  
  const fetchData = async (): Promise<void> => {
    loading.value = true;
    error.value = '';
  
    try {
      const response = await api.get('/api/statistics', {
        params: {
          year: selectedYear.value,
          month: selectedMonth.value,
          day: selectedDay.value
        }
      });
      
      stats.value = response.data;
      
      // Update charts with new data
      updateCharts();
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to fetch statistics';
      console.error('Error fetching statistics:', err);
    } finally {
      loading.value = false;
    }
  };
  
  const updateCharts = (): void => {
    // Destroy existing charts
    Object.values(charts.value).forEach(chart => {
      if (chart) {
        chart.destroy();
      }
    });
    
    // Create revenue chart
    createRevenueChart();
    
    // Create patients chart
    createPatientsChart();
    
    // Create expenses chart
    createExpensesChart();
    
    // Create appointments chart
    createAppointmentsChart();
  };
  
  const createRevenueChart = (): void => {
    const ctx = document.getElementById('revenueChart') as HTMLCanvasElement | null;
    if (!ctx) return;
    
    const labels = Array.isArray(stats.value.incomes) ? 
      stats.value.incomes.map((item) => format(parseISO(item.date), 'MMM d')) : [];
    
    const incomeData = Array.isArray(stats.value.incomes) ?
      stats.value.incomes.map((item) => parseFloat(item.amount) || 0) : [];
      
    const expenseData = Array.isArray(stats.value.expenses) ?
      stats.value.expenses.map((item) => parseFloat(item.amount) || 0) : [];
    
    const config: ChartConfiguration = {
      type: 'line',
      data: {
        labels,
        datasets: [
          {
            label: t('statistics.income'),
            data: incomeData,
            borderColor: chartColors.green,
            backgroundColor: `${chartColors.green}20`,
            tension: 0.3,
            fill: true,
          },
          {
            label: t('statistics.expenses'),
            data: expenseData,
            borderColor: chartColors.red,
            backgroundColor: `${chartColors.red}20`,
            tension: 0.3,
            fill: true,
          },
        ],
      },
      options: {
        ...chartOptions,
        plugins: {
          ...chartOptions.plugins,
          title: {
            display: true,
            text: t('statistics.revenue_vs_expenses'),
          },
        },
      },
    };
  
    charts.value.revenueChart = new Chart(ctx, config);
  };
  
  const createPatientsChart = (): void => {
    const ctx = document.getElementById('patientsChart') as HTMLCanvasElement | null;
    if (!ctx) return;
    
    const labels = Array.isArray(stats.value.patients) ?
      stats.value.patients.map((item) => format(parseISO(item.date), 'MMM d')) : [];
      
    const patientData = Array.isArray(stats.value.patients) ?
      stats.value.patients.map((item) => item.count || 0) : [];
    
    const config: ChartConfiguration = {
      type: 'bar',
      data: {
        labels,
        datasets: [
          {
            label: t('statistics.new_patients'),
            data: patientData,
            backgroundColor: chartColors.blue,
            borderRadius: 4,
          },
        ],
      },
      options: {
        ...chartOptions,
        plugins: {
          ...chartOptions.plugins,
          title: {
            display: true,
            text: t('statistics.patient_growth'),
          },
        },
      },
    };
  
    charts.value.patientsChart = new Chart(ctx, config);
  };
  
  const createExpensesChart = (): void => {
    const ctx = document.getElementById('expensesChart') as HTMLCanvasElement | null;
    if (!ctx || !Array.isArray(stats.value.expenses)) return;
    
    // Group expenses by category
    const categories = new Map<string, number>();
    stats.value.expenses.forEach((expense) => {
      const category = expense.category || 'Uncategorized';
      const amount = parseFloat(expense.amount) || 0;
      categories.set(category, (categories.get(category) || 0) + amount);
    });
    
    const labels = Array.from(categories.keys());
    const data = Array.from(categories.values());
    
    // Generate colors for categories
    const backgroundColors = labels.map((_, index) => {
      const colors = Object.values(chartColors);
      return colors[index % colors.length];
    });
    
    const config: ChartConfiguration = {
      type: 'doughnut',
      data: {
        labels,
        datasets: [
          {
            data,
            backgroundColor: backgroundColors,
            borderWidth: 1,
          },
        ],
      },
      options: {
        ...chartOptions,
        plugins: {
          ...chartOptions.plugins,
          title: {
            display: true,
            text: t('statistics.expenses_by_category'),
          },
        },
      },
    };
  
    charts.value.expensesChart = new Chart(ctx, config);
  };
  
  const createAppointmentsChart = (): void => {
    const ctx = document.getElementById('appointmentsChart') as HTMLCanvasElement | null;
    if (!ctx || !Array.isArray(stats.value.visits)) return;
    
    // Group visits by status
    const statuses = new Map<string, number>();
    stats.value.visits.forEach((visit) => {
      const status = visit.status || 'unknown';
      statuses.set(status, (statuses.get(status) || 0) + 1);
    });
    
    const labels = Array.from(statuses.keys()).map(status => 
      t(`appointments.statuses.${status.toLowerCase()}`)
    );
    const data = Array.from(statuses.values());
    
    // Generate colors for statuses
    const backgroundColors = labels.map((_, index) => {
      const colors = Object.values(chartColors);
      return colors[(index + 2) % colors.length]; // Offset to get different colors
    });
    
    const config: ChartConfiguration = {
      type: 'pie',
      data: {
        labels,
        datasets: [
          {
            data,
            backgroundColor: backgroundColors,
            borderWidth: 1,
          },
        ],
      },
      options: {
        ...chartOptions,
        plugins: {
          ...chartOptions.plugins,
          title: {
            display: true,
            text: t('statistics.appointments_by_status'),
          },
        },
      },
    };
  
    charts.value.appointmentsChart = new Chart(ctx, config);
  };
  
  // Lifecycle hooks
  onMounted(() => {
    // Check if already authenticated
    if (localStorage.getItem('statsAuthenticated') === 'true') {
      passwordCorrect.value = true;
      fetchData();
    }
  });
  
  // Clean up charts when component is unmounted
  onBeforeUnmount(() => {
    Object.values(charts.value).forEach(chart => {
      if (chart) {
        chart.destroy();
      }
    });
  });
  </script>
  